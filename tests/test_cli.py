"""Tests for CLI interface."""

from __future__ import annotations

import json
import subprocess
import sys
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from mev_analysis.cli import (
    _format_decimal,
    _result_to_dict,
    _setup_logger,
)
from mev_analysis.core.backtest import BacktestConfig, BacktestResult


class TestFormatDecimal:
    """Tests for _format_decimal helper."""

    def test_format_positive(self) -> None:
        """Should format positive decimal."""
        from decimal import Decimal
        result = _format_decimal(Decimal("0.123456789"))
        assert result == "0.123457"

    def test_format_zero(self) -> None:
        """Should format zero."""
        from decimal import Decimal
        result = _format_decimal(Decimal("0"))
        assert result == "0.000000"

    def test_format_negative(self) -> None:
        """Should format negative decimal."""
        from decimal import Decimal
        result = _format_decimal(Decimal("-0.05"))
        assert result == "-0.050000"


class TestResultToDict:
    """Tests for _result_to_dict helper."""

    def test_convert_empty_result(self) -> None:
        """Should convert empty backtest result."""
        from datetime import datetime, timezone
        from decimal import Decimal

        result = BacktestResult(
            backtest_id="bt_test123",
            config=BacktestConfig(),
            started_at=datetime(2025, 1, 15, 0, 0, 0, tzinfo=timezone.utc),
            completed_at=datetime(2025, 1, 15, 0, 1, 0, tzinfo=timezone.utc),
        )

        result_dict = _result_to_dict(result)

        assert result_dict["backtest_id"] == "bt_test123"
        assert result_dict["total_positions_scanned"] == 0
        assert result_dict["total_opportunities_detected"] == 0
        assert result_dict["num_windows"] == 0
        assert isinstance(result_dict["windows"], list)

    def test_convert_result_with_windows(self) -> None:
        """Should convert result with windows."""
        from datetime import datetime, timezone
        from decimal import Decimal

        from mev_analysis.core.backtest import WindowResult

        result = BacktestResult(
            backtest_id="bt_test456",
            config=BacktestConfig(),
            started_at=datetime(2025, 1, 15, 0, 0, 0, tzinfo=timezone.utc),
            completed_at=datetime(2025, 1, 15, 0, 2, 0, tzinfo=timezone.utc),
            windows=[
                WindowResult(
                    window_id="win_1000_2000",
                    start_block=1000,
                    end_block=2000,
                    num_positions_scanned=50,
                    num_opportunities_detected=5,
                    num_opportunities_simulated=50,
                    mean_ev_eth=Decimal("0.05"),
                    std_ev_eth=Decimal("0.02"),
                    ev_ci_lower_95=Decimal("0.01"),
                    ev_ci_upper_95=Decimal("0.09"),
                    mean_capture_probability=Decimal("0.03"),
                    capture_ci_lower_95=Decimal("0.01"),
                    capture_ci_upper_95=Decimal("0.05"),
                    mean_gas_gwei=Decimal("0.1"),
                    mean_eth_price_usd=Decimal("2000"),
                    duration_ms=100,
                ),
            ],
            total_positions_scanned=50,
            total_opportunities_detected=5,
            overall_mean_ev_eth=Decimal("0.05"),
        )

        result_dict = _result_to_dict(result)

        assert result_dict["num_windows"] == 1
        assert len(result_dict["windows"]) == 1
        assert result_dict["windows"][0]["window_id"] == "win_1000_2000"
        assert result_dict["windows"][0]["start_block"] == 1000


class TestSetupLogger:
    """Tests for _setup_logger helper."""

    def test_creates_logger(self, tmp_path: Path) -> None:
        """Should create experiment logger."""
        logger = _setup_logger(tmp_path, verbose=True)

        assert logger is not None
        # experiment_id is generated by the function as cli_YYYYMMDD_HHMMSS
        assert "cli_" in logger.experiment_id

    def test_creates_log_directory(self, tmp_path: Path) -> None:
        """Should create log directory."""
        _setup_logger(tmp_path, verbose=False)

        log_dir = tmp_path / "logs"
        assert log_dir.exists()


class TestCLIImports:
    """Tests that CLI module imports correctly."""

    def test_import_run_backtest(self) -> None:
        """Should import run_backtest function."""
        from mev_analysis.cli import run_backtest
        assert callable(run_backtest)

    def test_import_run_simulation(self) -> None:
        """Should import run_simulation function."""
        from mev_analysis.cli import run_simulation
        assert callable(run_simulation)

    def test_import_main(self) -> None:
        """Should import main function."""
        from mev_analysis.cli import main
        assert callable(main)


class TestCLIEntryPoints:
    """Tests for CLI entry points."""

    def test_backtest_help(self) -> None:
        """Should show help for backtest command."""
        result = subprocess.run(
            [sys.executable, "-m", "mev_analysis.cli", "backtest", "--help"],
            capture_output=True,
            text=True,
            cwd=Path(__file__).parent.parent,
        )

        # Should not error
        assert result.returncode == 0 or "usage" in result.stdout.lower()

    def test_simulate_help(self) -> None:
        """Should show help for simulate command."""
        result = subprocess.run(
            [sys.executable, "-m", "mev_analysis.cli", "simulate", "--help"],
            capture_output=True,
            text=True,
            cwd=Path(__file__).parent.parent,
        )

        # Should not error
        assert result.returncode == 0 or "usage" in result.stdout.lower()


class TestCLIBacktest:
    """Tests for backtest CLI functionality."""

    @pytest.fixture
    def output_dir(self, tmp_path: Path) -> Path:
        """Create output directory."""
        out = tmp_path / "output"
        out.mkdir()
        return out

    def test_backtest_with_synthetic_data(self, output_dir: Path, monkeypatch: pytest.MonkeyPatch) -> None:
        """Should run backtest with synthetic data."""
        from io import StringIO
        from unittest.mock import patch

        # Set SAFE_MODE environment variable
        monkeypatch.setenv("SAFE_MODE", "true")

        # Reset SafeMode singleton
        from mev_analysis.core.safe_mode import SafeMode
        SafeMode.reset()

        # Mock sys.argv
        with patch(
            "sys.argv",
            [
                "mev-backtest",
                "--synthetic",
                "--num-positions", "20",
                "--num-liquidatable", "5",
                "--num-iterations", "10",
                "--num-seeds", "2",
                "--output-dir", str(output_dir),
            ],
        ):
            # Capture stdout
            with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
                try:
                    from mev_analysis.cli import run_backtest
                    run_backtest()
                except SystemExit:
                    pass  # Allow exit

                output = mock_stdout.getvalue()

        # Should have run - check for either generation message or SAFE_MODE output
        assert "Generating" in output or "synthetic" in output.lower() or "RESEARCH MODE" in output

        # Reset singleton after test
        SafeMode.reset()

    def test_backtest_requires_input(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Should require input source."""
        from io import StringIO
        from unittest.mock import patch

        # Set SAFE_MODE environment variable
        monkeypatch.setenv("SAFE_MODE", "true")

        # Reset SafeMode singleton
        from mev_analysis.core.safe_mode import SafeMode
        SafeMode.reset()

        with patch("sys.argv", ["mev-backtest"]):
            with patch("sys.stderr", new_callable=StringIO):
                with pytest.raises(SystemExit) as exc_info:
                    from mev_analysis.cli import run_backtest
                    run_backtest()

                # Should exit with error
                assert exc_info.value.code == 1

        # Reset singleton after test
        SafeMode.reset()


class TestCLISimulation:
    """Tests for simulation CLI functionality."""

    def test_simulation_with_synthetic_data(self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
        """Should run simulation with synthetic data."""
        from io import StringIO
        from unittest.mock import patch

        # Set SAFE_MODE environment variable
        monkeypatch.setenv("SAFE_MODE", "true")

        # Reset SafeMode singleton
        from mev_analysis.core.safe_mode import SafeMode
        SafeMode.reset()

        output_dir = tmp_path / "output"
        output_dir.mkdir()

        with patch(
            "sys.argv",
            [
                "mev-simulate",
                "--synthetic",
                "--num-positions", "10",
                "--num-liquidatable", "3",
                "--num-iterations", "10",
                "--output-dir", str(output_dir),
            ],
        ):
            with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
                try:
                    from mev_analysis.cli import run_simulation
                    run_simulation()
                except SystemExit:
                    pass

                output = mock_stdout.getvalue()

        # Should have detected opportunities or shown message
        assert "Generating" in output or "synthetic" in output.lower() or "Detected" in output or "RESEARCH MODE" in output

        # Reset singleton after test
        SafeMode.reset()


class TestSampleDataLoading:
    """Tests for loading sample data files."""

    @pytest.fixture
    def sample_data_dir(self) -> Path:
        """Get sample data directory."""
        return Path(__file__).parent.parent / "sample_data"

    def test_sample_json_exists(self, sample_data_dir: Path) -> None:
        """Sample JSON file should exist."""
        json_file = sample_data_dir / "sample_positions.json"
        assert json_file.exists()

    def test_sample_csv_exists(self, sample_data_dir: Path) -> None:
        """Sample CSV file should exist."""
        csv_file = sample_data_dir / "sample_positions.csv"
        assert csv_file.exists()

    def test_sample_json_valid(self, sample_data_dir: Path) -> None:
        """Sample JSON should be valid."""
        json_file = sample_data_dir / "sample_positions.json"
        with open(json_file) as f:
            data = json.load(f)

        assert "positions" in data
        assert len(data["positions"]) > 0

    def test_sample_json_positions_have_required_fields(self, sample_data_dir: Path) -> None:
        """Sample JSON positions should have required fields."""
        json_file = sample_data_dir / "sample_positions.json"
        with open(json_file) as f:
            data = json.load(f)

        for pos in data["positions"]:
            assert "user_address" in pos
            assert "block_number" in pos
            assert "collaterals" in pos
            assert "debts" in pos
            assert "health_factor" in pos

    def test_sample_csv_positions_have_required_columns(self, sample_data_dir: Path) -> None:
        """Sample CSV should have required columns."""
        import csv

        csv_file = sample_data_dir / "sample_positions.csv"
        with open(csv_file) as f:
            reader = csv.DictReader(f)
            rows = list(reader)

        assert len(rows) > 0

        required_columns = ["user_address", "block_number", "health_factor"]
        for col in required_columns:
            assert col in rows[0], f"Missing column: {col}"
